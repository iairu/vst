improve README.md to properly explain physics behind these features, do not remove any content:

- Auto Level: It automatically equalizes the volume, so that it's not quiet and loud at times.
- Pitch: It fine-tunes false notes to make it sound professional.
- Deesser: We erase those sharp "S" and "C", we clean it up like a mess.
- Compressor: The absolute basics, it makes the voice fat, hard and pulls it forward.
- EQ and Saturation: Gives it color and that expensive shine.
- Reverb: So that it doesn't sound dry, but it has space.

---

# AIV Vocal Chain

AIV (Artificial Intelligence Vocal) Chain is a comprehensive Logic Pro AudioUnit extension designed to deliver professional-grade vocal processing. It combines a suite of essential audio effects into a single, high-performance C++ DSP kernel with a modern, hardware-accelerated SwiftUI interface.

This plugin allows users to transform raw vocal recordings into polished, radio-ready tracks using a specific chain of processing modules: Auto Level, Pitch Correction, De-esser, EQ, Compression, Saturation, Filtering, Delay, and Reverb.

## Signal Flow

The audio signal passes through the modules in the following order:

`Input` → `Auto Level` → `Pitch Correction` → `De-esser` → `Equalizer` → `Compressor` → `Saturation` → `Filter` → `Delay` → `Reverb` → `Output`

---

## Features & DSP Physics

Each module in the AIV Vocal Chain is built upon fundamental Digital Signal Processing (DSP) principles. Below is an explanation of each feature alongside the governing physics and mathematical equations.

### 1. Auto Level (Automatic Gain Control)
**Function**: Smooths out dynamic inconsistencies in the vocal performance before it hits the rest of the chain, ensuring a consistent input level.
**Controls**: Target (dB), Range (dB), Speed (0-100%).

**Physics/Math**:
The Auto Leveler uses an RMS (Root Mean Square) detector to estimate signal power and apply gain. The envelope detection is modeled by a first-order low-pass filter:

$$ y_{env}[n] = \alpha \cdot |x[n]| + (1 - \alpha) \cdot y_{env}[n-1] $$

Where $\alpha$ is determined by the `Speed` parameter. The gain applied $g[n]$ is calculated to bring $y_{env}$ towards the `Target` level $L_T$:

$$ g[n] = \left(\frac{10^{L_T/20}}{y_{env}[n]}\right)^k $$

Where $k$ is a scaling factor derived from the `Range`.

### 2. Pitch Correction
**Function**: Corrects the pitch of the vocal to the nearest chromatic semitone.
**Controls**: Amount (%), Speed (%).

**Physics/Math**:
Pitch detection is typically performed using autocorrelation or zero-crossing analysis to find the fundamental frequency $f_0$. The target frequency $f_{target}$ is the nearest note in the 12-tone equal temperament scale:

$$ f_{note} = 440 \cdot 2^{(n-69)/12} $$

The correction shifts the input signal using a time-domain pitch shifting algorithm (like PSOLA) or a circular buffer delay line where the read pointer speed varies relative to the write pointer:

$$ y[t] = x[t \cdot \frac{f_{target}}{f_{measured}}] $$

### 3. De-esser
**Function**: Attenuates harsh sibilance ("s", "sh", "ch" sounds) in the high frequencies.
**Controls**: Threshold (dB), Frequency (Hz), Ratio.

**Physics/Math**:
The De-esser is a frequency-dependent compressor. The control signal is generated by a high-pass filter (sidechain):

$$ H(z) = \frac{1 - z^{-1}}{1 - p \cdot z^{-1}} $$

When the energy in this filtered band exceeds the `Threshold`, gain reduction is applied to the broadband signal:

$$ G_{dB} = \text{Ratio} \cdot (\text{Input}_{dB} - \text{Threshold}_{dB}) $$

### 4. Parametric Equalizer (EQ)
**Function**: Sculpts the tonal balance with 3 bands (Low, Mid, High).
**Controls**: Frequency (Hz), Gain (dB), Q (Bandwidth).

**Physics/Math**:
Each band is implemented as a second-order IIR (Infinite Impulse Response) Biquad filter. The transfer function in the z-domain is:

$$ H(z) = \frac{b_0 + b_1 z^{-1} + b_2 z^{-2}}{a_0 + a_1 z^{-1} + a_2 z^{-2}} $$

For a peaking EQ filter, the coefficients ($a_n, b_n$) are calculated based on center frequency $\omega_0 = 2\pi f_c / f_s$ and quality factor $Q$:

$$ \alpha = \frac{\sin(\omega_0)}{2Q} $$

### 5. Compressor
**Function**: Reduces the dynamic range of the vocal, making loud parts quieter and soft parts louder.
**Controls**: Threshold, Ratio, Attack, Release, Makeup Gain.

**Physics/Math**:
The compressor calculates a gain factor $g[n]$ based on the signal level relative to the threshold. The dynamic characteristics are defined by the attack ($\tau_a$) and release ($\tau_r$) time constants:

$$ c[n] = \begin{cases} \alpha_{att} c[n-1] + (1-\alpha_{att})x_{dB}[n] & x_{dB} > c[n-1] \\ \alpha_{rel} c[n-1] + (1-\alpha_{rel})x_{dB}[n] & x_{dB} \le c[n-1] \end{cases} $$

The final output is:
$$ y[n] = x[n] \cdot 10^{(Makeup - GainReduction)/20} $$

### 6. Saturation
**Function**: Adds harmonic distortion to warm up the vocal or add grit.
**Controls**: Drive (%), Type (Tube/Tape).

**Physics/Math**:
Saturation is achieved through static non-linear waveshaping functions. A common function for soft-clipping (Tube-like saturation) is the hyperbolic tangent:

$$ y[n] = \tanh(k \cdot x[n]) $$

Where $k$ is the `Drive` factor. As $k$ increases, the linear region shrinks, flattening the peaks of the waveform and introducing odd-order harmonics (3rd, 5th, etc.).

### 7. Resonant Low-Pass Filter
**Function**: Removes high-frequency content with an optional resonant peak at the cutoff point.
**Controls**: Cutoff (Hz), Resonance (dB).

**Physics/Math**:
Modeled as a digital state-variable filter or a resonant Biquad. The resonance causes a gain boost at the cutoff frequency $\omega_c$. The differential equation for a simplified 1-pole resonant filter could be viewed as:

$$ y[n] = (1-q)\cdot x[n] + q \cdot y[n-1] $$ (Simple LPF)

With resonance feedback added to the input:
$$ Input_{filter} = x[n] + \text{Resonance} \cdot (x[n] - y[n-1]) $$

### 8. Delay
**Function**: Creates repeating echoes of the vocal.
**Controls**: Time (s), Feedback (%), Mix (%).

**Physics/Math**:
A delay is implemented using a circular buffer (memory array). The output is the input from $D$ samples ago:

$$ y[n] = x[n] + g_{fb} \cdot y[n-D] $$

Where $D = \text{Time} \cdot f_s$ (samples) and $g_{fb}$ is the feedback gain.

### 9. Reverb
**Function**: Simulates the acoustic space (room/hall) around the vocal.
**Controls**: Size (%), Damp (%), Mix (%).

**Physics/Math**:
The reverb is based on the Schroeder/Moorer architecture, combining a series of specific filters:

1.  **Comb Filters**: Simulate early reflections ($y[n] = x[n] + g y[n-M]$).
2.  **All-Pass Filters**: Increase reflection density without altering frequency magnitude ($H(z) = \frac{-g + z^{-M}}{1 - g z^{-M}}$).

The `Damp` parameter introduces a low-pass filter in the feedback loop of the comb filters, simulating the absorption of high frequencies by air and walls over time.

---

## Technical Stack

*   **Language**: C++ (DSP Kernel), Swift (UI & Logic)
*   **Frameworks**: CoreAudio, AudioToolbox, SwiftUI, AVFoundation
*   **Architecture**: AUAudioUnit (v3)
*   **Platform**: macOS & iOS

## Integration

1.  Open Logic Pro X or GarageBand.
2.  Create an Audio Track.
3.  Load `AIVDemo` from the Audio Units list under your manufacturer name.
4.  The custom SwiftUI interface will launch, providing real-time control over all parameters.